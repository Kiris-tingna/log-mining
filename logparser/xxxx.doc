
BSGI算法概述
Author: 郭舒婷

图1 BSGI算法过程示意图
南邮设计的主干提取算法包括两个阶段：第一阶段是搜索阶段（Search Phase），为新的日志消息查找正确的日志格式，第二阶段是调整阶段（Adjustment Phase），以调整和优化现有格式。
一、搜索阶段（Search Phase）
搜索阶段的算法是我们设计的基本标签生成算法（Basic Signature Generation Algorithm）。该方法可以分成以下四个步骤：首先对待解析日志进行领域知识预处理；其次，根据日志的长度划分到对应的日志长度层；接着，根据日志头尾部的关键词进一步划分到对应日志关键词层；最后与层内的所有模板进行比较选择/新建合适的模板。
1.1 日志预处理层（Preprocessing Layer）
数据预处理是数据挖掘前的准备工作，它既能保证挖掘数据的有效性和正确性，又能通过对数据格式和内容进行调整，从而使数据更符合挖掘的需要。其主要任务是根据北京知识钟的约束性规则对数据进行检查，通过清理和归纳等操作，生成供数据挖掘算法使用的目标数据。随着存储技术的发展，收集到的日志与实际有效日志之间的矛盾日渐突出；同时，未处理的原始日志必然导致日志解析代价增加。数据预处理模块是提高解析精度的关键。
我们对日志的预处理工作主要氛围位置固定无关项的去除和位置不定相关项的规范。
(1)位置固定无关项的去除
原始日志数据中通常有一些固定不变的项，且它们在每条日志中出现的位置一样，如日志数据集中代表日志产生日期的2017-12-14；或者虽然变化，但是属性一样，如08:00:00与08:00:06虽然不同但都是时间。这些项不仅对日志分类没有帮助，而且会造成代价的增加。
(2)位置不定相关项的规范
日志中还有一些项，它们的属性一样，但是出现位置并不固定，如IP地址、端口号等，此外这些相关项是日志格式的重要组成部分，不能随意删除。本文考虑利用匹配字串的原理采用正则表达式来规范化这些项。
1.2 日志长度层（Length Layer）
以前的研究工作表明，从相同长度的日志中提取事件可以获得良好的分析结果。类似于这些研究工作，我们在日志长度层将日志信息按照长度进行分组，所有日志信息在同一个包中具有相同的长度。注意到可能有存在一个事件签名可以具有不同长度的日志的情况，例如，对于同一事件，“delete block blk[*]”和“delete block blk[*]blk[*]”。我们的方法是在生成模版（签名）时将参数项去重合并不同的模板来解决这部分的问题。
1.3 日志关键词层（Keyword Layer）
根据现有的日志解析经验，开发人员倾向于使用常量开始或结束日志消息。例如日志消息“Send file 01”以常量字段“Send”开始，而日志消息“10 bytes is sent” 则以常量字段“sent”结束。我们的算法在关键词层中关注日志消息的第一个字段和最后一个字段，如果日志消息的第一个字段不包含任何数字或特殊字符，则将第一个字段视为关键词，否则查看最后一个字段是否不包含任何数字或者或者特殊字符，如果不包含，则将最后一个字段视为关键词，不然该日志的关键词为空。
1.4 比较层（Comparison Layer）

图2 基本签名生成的过程
事件特征抽取过程本质上是最长公共子序列（LCS）问题，它被证明是一个NP难问题。因此，在日志序列之间寻找最长的公共子序列是不现实的，因为之前定义的每个日志包中的长度都是固定的，所以我们使用编辑距离（Edit Distance）来代替计算最长的公共子序列（LCS）。我们提出的基本签名生成的过程如图2所示。在比较层中，我们创建了几个称为SIGMAP的对象，每个对象具有唯一的日志长度。与Spell[15]类似，在每个SigMap中，我们创建一个名为SigObj的数据结构来保存当前解析的事件签名和相关元数据信息。每个SigObj都包含一个解析模板和一个行索引列表，该列表存储导致此签名的相应条目的行ID。当一个新的日志消息到达时，我们首先计算它的令牌的长度并找到它所属的SIGMAP。然后，通过将此日志消息与所有签名进行比较来生成新签名。
Trick: 提早放弃策略（Early Abandoning Technique）加速比较计算
提早放弃策略是加速欧拉距离相似度距离搜索的有用策略。我们借鉴了该思想，在新的日志消息和所在比较层的所有的日志模板进行比较时，引入提早放弃策略，加速比较计算。
设待比较的日志消息为seq，待比较的模板为tem，则原始的相似度计算公式为：

其中l为日志消息的长度，n_c为日志模板tem当前非变量字段的个数。cost函数计算公式为：

当时，说明该日志消息可以插入到该模板中。seq和tem相同字段的个数可以表示为，不同字段的个数表示为。则可以表示成。利用该公式，我们可以在逐字段比较过程中记录seq和tem不同字段的个数，当累计的不同字段个数超过了(1-st)*nc，则提前结束比较过程。运用提早放弃策略可以帮助我们跳过大量的计算。
1.5 自适应参数选取
基本签名生成类似于流数据的聚类。 与使用隐式事件特征来指导参数调整的其他日志解析方法不同，我们建议在聚类验证中采用类似的策略来调整我们的过程中仅具有显式特征的阈值st。该阈值st的调整对解析精度和应用性能具有重要意义。在基本事件签名生成中，阈值st引导算法建立一个新的SigObj.大多数现有日志解析方法首先根据正则表达式生成真实的日志签名（模板），然后再根据这些日志模板来调整日志解析方法中涉及到的参数，然而事实上例如真实事件类型（模板）要么不好获取，要么不能保证获取模板的准确性。
聚类验证是验证帧内相似性高，而簇间相似性低。 与聚类验证类似，在基本签名生成中，我们希望具有相同签名的日志与具有不同签名的日志（即紧凑性和分离）更相似。 紧凑度衡量日志的密切关系，分离度量衡量不同签名的日志分离程度。
定义1签名紧凑性。 令ctr表示事件签名r中的常量字段的数量，lr表示r的长度。 然后签名r的紧凑性定义如下：

紧凑度g测量签名的常数字段的比率，越大表示事件签名越紧凑。
就像簇之间的距离一样，通过簇之间的距离来测量，我们使用相同签名的日志之间的距离。
类之间的分离程度主要是评估类之间的松散程度，直觉中，类之间的距离越大，松散程度越好。 文本之间的距离主要包括jaccard距离和余弦距离。 由于日志消息文本的格式是固定的，因此由相同令牌位置表示的事件不一定相同。 签名之间的距离需要考虑令牌的位置信息，同时事件签名的长度变化。 我们使用字段对（Token Pairs）对来解决上述两个问题。
字段对可以保留日志消息字段的顺序信息。 构造字段对有两个优点：（1）转换后的字段对保留了消息术语的顺序信息; （2）离散项对的计算比字段序列更容易。
例如，有一个从BGL解析的日志模板：
RAS KERNEL INFO generating core [*]
我们删除所有参数（通配符）（标记为[*]）并提取每个成对的术语并保留两个术语的顺序。 转换后的术语对表示如下：
(RAS,KERNEL), (RAS,INFO), (RAS,generating), ,
(RAS,core), (KERNEL,INFO), (KERNEL,generating),
(KERNEL,core), (INFO,generating), (INFO,core), (generating,core)
定义2签名分离度。Jaccard距离使用两个字段对集合中的不同元素与所有元素的比率来测量两个字段对集合之间的区分程度。字段对的Jaccard距离定义如下：

对于每个术语对集合，我们使用它和其他字段对设置最小jaccard距离来描述模板之间的分散程度。 在这个日志解析任务中，我们更注重分离而不是紧凑，我们将聚类得分如下：

在实际使用中，我们对日志数据进行采样以选择最佳阈值，该阈值可获得关于scluster的最大值。

二、调整阶段（Adjusting Phase）
2.1 创建/更新模板
当日志找不到合适的插入模板时，将会在所在的比较层新建一个SigObj对象，此时该对象的模板就是该条日志消息。当日志找到合适的插入模板时，则会对待插入SigObj对象的模板进行更新，在模板的每个字段上与日志消息对应字段字段逐个比较，若相同则保留字段为常量字段，否则标记模板字段为变量字段，用参数（通配符）表示。
2.2 分割模板：重定义模板
具有不同语义或频繁参数值的类似消息应当位于不同的事件中。在现有的大多数日志解析方法里，它们都基于日志本身结构分析而设计的模型，忽略语义特征最终导致不同语义或频繁参数值的类似的消息被认为是相同的事件。例如两条日志消息（通常日志消息会更长，但是仅仅有两个单词不同”up”和”down”）：”Network is up”和”Network is down”。它们分别表示了“网络已经连接”和“网络已经断开”两条内容，由于仅仅有一个位置上的单词不同，它们很容易地被划分成同一个事件，而这个事件的签名是“Network is *”。另一方面，一条日志消息签名可以是”login user *”，这里的”*”里存储了host的信息（如root、ip地址等等）。可能存在很多日志“login user root”，而剩余的host的信息则多种多样，在这种情况下”root”需要考虑从”*”中剥离出来。
为了在这种情况下产生期望的结果，我们的算法基于消息中的单词位置的熵和每个位置内的单词来分割簇，以在单词位置中考虑参数的簇的成员之间保持高熵。为了加速计算，考虑采用最小基尼指数来作为最大熵的近似。我们提出了基于最小基尼分割的模板重定义算法（CRMGS）
Algorithm: Cluster Refinement based on Minimum Gini Split(CRMGS)
Parameter: MinLogtNum, MaxTokenNum, MaxGini 
CRMGS(cluster):
SplitPos = -1
if cluster.LogNum < MinLogtNum: return SplitPos
log_template = cluster.log_template
split_pos, split_gini = -1, 1
for c_pos, token in enumerate(log_template):
if token == '*' :
If len(cluster.token_dict[c_pos]) < MaxTokenNum:
            square_sum = 0
            for word in cluster.token_dict[c_pos]:
                num = len(cluster.token_dict[c_pos][word])
                square_sum += float(num) ** 2
            gini = 1 - square_sum / (cnt ** 2)
            if gini <= MaxGini and gini < split_gini:
                split_pos, split_gini = c_pos, split_gini
      return split_pos

基于最小基尼分割的模板重定义算法（CRMGS）在分裂模板时受到以下几个条件的限制：
（1）模板最小日志数量（MinLogtNum）：若当前解析到该模板的数量过少，即模板的参数存储的信息有限，则暂时不予以分裂模板。
（2）模板参数最大可分割数（MaxTokenNum）：若模板在某个位置上的参数种类非常多，则一定程度上表示该位置是参数的可能性越高，此时不予以分裂。
（3）模版参数最大基尼值（MaxGini）：当模版参数在某个位置上的参数的熵值超过模版参数最小熵值，才可以作为分裂的候选位置。


